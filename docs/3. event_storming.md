아래는 “프로세스 기반(Event Storming – Process Modeling / Design-level)”으로, 가계부 서비스(Release 1)에서 실제로 일어나는 비즈니스 흐름을 시간 순으로 두고, 
그 흐름에서 도출되는 도메인 이벤트(과거형), 커맨드(명령형), 액터, 정책(Whenever X then Y)을 정리한 문서입니다.
Event Storming에서는 보통 “도메인 이벤트(무슨 일이 일어났는가) → 그 앞의 커맨드(무슨 행동을 했는가) → 그 커맨드를 누가/무엇이 트리거했는가(Actor/Policy)” 순서로 정리합니다.
또한, 도메인 이벤트는 “도메인에서 발생한 의미 있는 사실을 알리는 것”이고, 파생 동작(후속 처리)을 명시적으로 만들기 위한 수단입니다.

────────────────────────────────────────────────────────
1. 액터(Actors)
────────────────────────────────────────────────────────
* 사용자(User): 거래, 자산, 분류, 예산, 고정비 템플릿를 직접 조작하고 리포트를 조회한다.
* 스케줄러(Scheduler): 고정비 템플릿에 의해 “거래 내역 자동 생성”을 트리거한다(시간 기반 자동화).
* 시스템(System UI/Backend): 사용자 요청을 처리하고 리포트를 산출한다(Actor라기보다 실행 주체로 표현).

────────────────────────────────────────────────────────
2. 핵심 비즈니스 프로세스별 이벤트/커맨드/정책
────────────────────────────────────────────────────────
A. 거래 기록(지출/수입) 프로세스 (Ledger 중심)
Actor: 사용자(User)

Command 1: 
* RecordTransaction(거래를 기록한다)
* UpdateTransaction(거래를 수정한다)
* DeleteTransaction(거래를 삭제한다)

Event 1: 
* TransactionRecorded(거래가 기록됨)
* TransactionUpdated(거래가 수정됨)
* TransactionDeleted(거래가 삭제됨: soft delete 의미로 “숨김 처리됨”)

Command 2:
* AssignCategoryToTransaction(거래에 카테고리를 지정한다)
* AddTagToTransaction(거래에 태그를 추가한다)
* RemoveTagFromTransaction(거래에서 태그를 제거한다)

Event 2:
* Transaction Categorized(거래에 카테고리가 지정됨)
* Transaction Tag Added(거래에 태그가 추가됨)
* Transaction Tag Removed(거래에서 태그가 제거됨)

Command 3:
* AddTransactionAttachment(거래에 첨부를 추가한다)
* DeleteTransactionAttachment(거래 첨부를 삭제한다)
* ViewTransactionAttachment(거래 첨부를 조회한다)

Event 3:
* TransactionAttachmentAdded(거래에 첨부가 추가됨)
* TransactionAttachmentDeleted(거래 첨부가 삭제됨)
* AttachmentAccessDenied(첨부 접근이 거부됨)

Policy: 
* Whenever Transaction Recorded(거래가 기록되면)
* then Reflect In Monthly Report(월간 리포트에 반영한다)
* 주의: 반영 방식(동기/비동기, "어떻게"에 해당)은 전술적 설계에서 결정

Rule:
* 거래가 삭제되면, 이후 리포트/조회에서 “삭제된 거래는 집계/표시 대상이 아니다”
* 거래당 태그 개수는 최대 N개로 제한한다.
* 거래당 첨부 개수는 최대 N개로 제한한다.
* 주의: “제외”가 즉시인지 지연인지, 캐시/프로젝션 반영 방식은 전술 설계에서 결정

B. 이체 기록 프로세스 (Transfer, Ledger 내 별도 플로우)
Actor: 사용자(User)

Command 1:
* RecordTransfer(이체를 기록한다)
* UpdateTransfer(이체를 수정한다)
* DeleteTransfer(이체를 삭제한다)

Event 1:
* TransferRecorded(이체가 기록됨)
* TransferUpdated(이체가 수정됨)
* TransferDeleted(이체가 삭제됨: soft delete 의미로 “숨김 처리됨”)

Rule:
* 이체는 출금 자산과 입금 자산이 동일할 수 없다(From/To Asset Must Be Distinct)
* 주의: 검증 지점(서버/클라이언트)은 전술 설계에서 결정

C. 고정비 템플릿 관리 프로세스 (Automation 중심)
Actor: 사용자(User)

Command 1:
* RegisterFixedCostTemplate(고정비 템플릿을 등록한다)
* UpdateFixedCostTemplate(고정비 템플릿을 수정한다)
* DeactivateFixedCostTemplate(고정비 템플릿을 비활성화한다)

Event 1:
* FixedCostTemplateRegistered(고정비 템플릿이 등록됨)
* FixedCostTemplateUpdated(고정비 템플릿이 수정됨)
* FixedCostTemplateDeactivated(고정비 템플릿이 비활성화됨)

Rule:
* 템플릿 변경으로 인한, 소급은 적용하지 않는다.

D. 고정비 자동 생성 프로세스 (Automation → Ledger)
Actor:
* 스케줄러(Scheduler)
* 사용자(User)

Command 1:
* TriggerFixedCostAutoGeneration(고정비 자동 생성을 트리거한다)

Event 1:
* FixedCostAutoGenerationTriggered(고정비 자동 생성이 트리거됨)
* FixedCostAutoGenerationFailed(고정비 자동 생성이 실패함)

Policy:
* Whenever Fixed Cost Auto-Generation Triggered(고정비 자동 생성이 트리거되면)
* then Generate Fixed Cost Transaction(고정비 거래를 생성한다)
* 주의: 멱등/중복 방지, 실패/재시도 방식(“어떻게”)은 전술적 설계에서 결정

Command 2:
* GenerateFixedCostTransaction(고정비 거래를 생성한다)

Event 2:
* FixedCostTransactionGenerated(고정비 거래가 생성됨)

Policy:
* Whenever FixedCostAutoGenerationFailed(고정비 자동 생성이 실패하면)
* then Allow User To Detect Missing Fixed Cost(사용자가 누락을 인지하고 보정할 수 있도록 한다)
* 주의: UI, 리스트, 상태 모델은 전술 설계에서 결정

Rule:
* 자동 생성된 거래는 ‘자동 생성 출처’를 식별 가능해야 한다.
* 동일 기간(월) 내 동일 고정비는 “최대 1회만” 자동 생성되어야 한다.

E. 월 예산 관리 프로세스 (Budget 중심, Release 1: Monthly Only)
Actor: 사용자(User)

Command 1:
* SetMonthlyBudget(월 예산을 설정한다)
* UpdateMonthlyBudget(월 예산을 수정한다)
* ClearMonthlyBudget(월 예산을 해제한다)

Event 1:
* MonthlyBudgetSet(월 예산이 설정됨)
* MonthlyBudgetUpdated(월 예산이 수정됨)
* MonthlyBudgetCleared(월 예산이 해제됨)

Rule:
* 예산 대비(Budget Compare)는 예산 설정값을 기준으로 산출한다.
* 주의: 반영 방식(동기/비동기, 캐시/프로젝션)은 전술적 설계에서 결정

F. 월간 리포트 조회 프로세스 (Reporting 중심)
Actor: 사용자(User)

Command 1:
* ViewMonthlyReport(월간 리포트를 조회한다)

Event 1:
* MonthlyReportViewed(월간 리포트가 조회됨)

Rule:
* 월간 리포트는 거래 ‘발생 월’ 기준으로 집계한다.
* 지출/예산 비교 집계는 수입/지출 거래만을 대상으로 한다.(이체 제외)
* 카테고리는 2-depth 집계 후 1-depth로 롤업해 제공한다.
* 자산 축 합계를 제공한다.
* 태그 축 합계를 제공한다.
* 예산 대비를 제공한다.
* 주의: 리포트 산출 방식(동기 조합 vs 사전 집계)은 전술적 설계에서 결정

G. 카테고리 관리 프로세스 (Category, Classification 중심)
Actor: 사용자(User)

Command 1:
* CreateCategory(카테고리를 생성한다)
* UpdateCategory(카테고리를 수정한다)
* DeactivateCategory(카테고리를 비활성화한다)

Event 1:
* CategoryCreated(카테고리가 생성됨)
* CategoryUpdated(카테고리가 수정됨)
* CategoryDeactivated(카테고리가 비활성화됨)

Rule:
* 카테고리는 최대 2-depth를 보장한다.
* 비활성화된 카테고리는 신규 거래에서 선택될 수 없다.
* 주의: 깊이 계산 및 검증 방식은 전술적 설계에서 결정

H. 태그 관리 프로세스 (Tag, Classification 중심)
Actor: 사용자(User)

Command 1:
* CreateTag(태그를 생성한다)
* UpdateTag(태그를 수정한다)
* DeactivateTag(태그를 비활성화한다)

Event 1:
* TagCreated(태그가 생성됨)
* TagUpdated(태그가 수정됨)
* TagDeactivated(태그가 비활성화됨)

Rule:
* 태그의 정규화명은 중복될 수 없다.
* 비활성화된 태그는 신규 거래에서 선택될 수 없다.
* 주의: 정규화 규칙과 충돌 처리는 전술적 설계에서 결정

I. 자산 관리 프로세스 (Asset 중심)
Actor: 사용자(User)

Command 1:
* RegisterAsset(자산을 등록한다)
* UpdateAsset(자산을 수정한다)
* DeactivateAsset(자산을 비활성화한다)

Event 1:
* AssetRegistered(자산이 등록됨)
* AssetUpdated(자산이 수정됨)
* AssetDeactivated(자산이 비활성화됨)

Rule:
* 비활성화된 자산은 신규 거래에서 선택될 수 없다.
* 주의: 적용 범위(입력 UI 제한, 서버 검증)는 전술적 설계에서 결정

J. 인증/세션 프로세스 (Identity & Session 중심, Release 1: Session-based)
Actor: 사용자(User)

Command 1:
* AuthenticateUser(사용자를 인증한다)
* Logout(로그아웃한다)

Event 1:
* UserAuthenticated(사용자가 인증됨)
* UserLoggedOut(사용자가 로그아웃함)

Command 2:
* EstablishSession(세션을 수립한다)
* TerminateSession(세션을 종료한다)

Event 2:
* SessionEstablished(세션이 수립됨)
* SessionTerminated(세션이 종료됨)

Rule:
* 어떤 리소스 접근 요청이 오면 소유권을 검증한다.
  * 범위: Transaction, Asset, Category, Tag, Budget, FixedCostTemplate, Attachment, Report
  * 주의: 구현 위치(Controller, Service, Repository)와 실패 응답은 전술 설계에서 결정
* 리소스가 비활성화되면 신규 생성/수정에서 참조로 사용할 수 없다.
  * 주의: 적용 범위(UI/서버)와 “기존 데이터 표시” 허용 범위는 전술 설계에서 결정

