
────────────────────────────────────────────────────────
1. 서브 도메인 분류 (Core / Supporting / Generic)
────────────────────────────────────────────────────────

도메인 주도 설계(DDD)에서 모든 비즈니스 로직을 동일한 중요도로 취급하면 리소스 배분에 실패하게 됩니다. 
이를 방지하기 위해, 도메인을 비즈니스 가치와 복잡도에 따라 세 가지 서브도메인(Subdomain)으로 분류합니다.
* 핵심 도메인(Core Domain): 비즈니스의 성공을 결정짓는 가장 핵심적인 영역으로, 타사 서비스와 차별화되는 고유한 비즈니스 로직이 포함
* 지원 도메인 (Supporting Subdomain): 핵심 도메인을 작동시키기 위해 반드시 필요하지만, 그 자체가 비즈니스 우위를 점하게 하지는 않는 영역
* 일반 도메인 (Generic Subdomain): 공통적이고 반복적인 문제를 다루며, 검증된 솔루션이나 상용 소프트웨어로 대체 가능한 영역

1.1 Core Subdomain (핵심)
본 제품의 가치가 “기록 → 분류 → 월말 회고(인사이트)” 루프에 있고, 특히 태그 기반 목적 분류, 자산 원천 추적, 카테고리 롤업을 결합한 해석이 제품 정체성(차별점)에 가장 가깝습니다.
* 소비 해석을 위한 다축 회고(자산/카테고리 롤업/태그)
* 월 예산 대비 비교의 ‘리포팅 경험’

1.2 Supporting Subdomains (지원)
Supporting으로 둔 이유는 “제품 운영에 필수”지만, 본질적으로 리포트/회고 경험을 ‘돕는’ 기능군이기 때문입니다.
* 거래 기록/관리(수입·지출) 및 이체(별도 입력 경험 포함)
* 분류(카테고리 2-depth 구조, 태그 횡단 분류)
* 자산(카드/현금/계좌) 관리(원천 추적)
* 월 예산 설정(Release 1: 월 예산만)
* 고정비 템플릿 기반 자동 생성(반복 입력 제거)

1.3 Generic Subdomains (일반)
Generic은 통상적으로 ‘검증된 솔루션 활용’이 선호되는 영역입니다.
* 인증/인가(로그인, 세션, 권한)
* 파일 저장/전송 인프라
* 알림(푸시/이메일 등 채널 자체)
* 스케줄러/잡 실행 프레임워크(Quartz/Spring Scheduler 등 “수단”)
* 로깅/모니터링/운영 도구


────────────────────────────────────────────────────────
2. 바운디드 컨텍스트 경계 설정
────────────────────────────────────────────────────────

바운디드 컨텍스트는 “모델이 유효한 의미 경계”이며, 컨텍스트 맵으로 관계를 명시합니다.
Release 1은 “운영 경험”이 중요하므로, 우선 모듈 경계를 명확히 하는 방향(모듈러 모놀리스/단일 배포 가능)을 전제로 경계를 잡는 것이 합리적입니다(분산은 다음 단계의 선택).

2.1 바운디드 컨텍스트(BC) 목록과 책임

A. Identity & Access BC
* 분리 이유: 
  업무 도메인(가계부/리포트) 모델에 인증, 세션, 토큰, 암호 등 보안 관심사를 섞으면 유비쿼터스 언어가 오염되고 변경 파급이 커집니다. 
  Vernon도 “Identity and Access Context”를 별도 경계로 분리해 다른 컨텍스트가 이를 Generic Subdomain으로 소비하는 구성을 명시합니다.
* 책임(무엇을 소유/결정하는가)
  * 사용자 식별(Identity): userId(주체 식별자), 계정 상태(활성/비활성 등)
  * 인증(Authentication): 로그인, 자격 증명 검증(구현 세부는 전술)
  * 세션/토큰 발급(Session/Token Issuance): access token / refresh token 발급, 만료/회수 정책(Release 1 수준 최소화)

B. Ledger BC (Transaction & Transfer)
* 분리 이유: 
  가계부에서 “거래”는 가장 높은 빈도/중요도의 쓰기 모델이며, 수정/삭제(soft delete), 이체(별도 입력 경험), 자동 생성 거래의 출처 표기 등 자체 규칙이 많습니다. 
  이 모델은 리포트/분류/예산과 결합되기 쉽기 때문에, 경계를 명확히 하지 않으면 리포트 관점의 요구가 거래 모델을 오염시키기 시작합니다.(예: 집계 편의를 위해 거래를 왜곡) 
  Bounded Context는 이런 내부 일관성 유지를 위해 필요합니다.
* 책임: 
  * 수입/지출 거래 관리
  * 이체 거래 관리
  * 거래 분류 연결(카테고리/태그의 식별자 참조)
  * 거래 귀속 첨부 관리: 거래에 첨부 추가/삭제/조회
  * 거래의 출처 식별: 사용자 수동 입력인지, 고정비 템플릿 자동 생성인지.(사용자가 알 수 있어야 함)
  * 거래와 외부 식별자 연결(자산/카테고리/태그/첨부/템플릿 참조는 "식별자 참조"로만 취급)

C. Classification BC (Category & Tag)
* 분리 이유: 
  카테고리(최대 2-depth)와 태그(normalizedName 유니크, 비활성화 정책)는 “데이터 품질”과 “분류 UX”에 강하게 결합되며, 거래/리포트와는 다른 변화 이유를 가집니다. 
  동일한 “카테고리/태그”라는 단어라도, 거래 입력에서는 선택지이고 리포트에서는 집계 차원입니다. 경계가 없으면 집계 요구가 분류 정책을 잠식합니다. 
  Bounded Context는 “같은 단어의 다른 의미”를 분리하는 장치입니다.
* 책임: 
  * 카테고리 생성/수정/비활성, 최대 2-depth 구조 유지
  * 태그 생성/수정/비활성, normalizedName 유니크 및 이름 표시 규칙
  * 거래와의 연결을 위한 식별자 제공(거래가 분류 모델 내부로 침투하지 않도록)

D. Asset BC
* 분리 이유:
  자산(카드/현금/계좌)은 “원천 추적”이라는 목적이 명확하고, Release 1에서 잔액/정산을 하지 않는다는 범위 원칙이 있습니다. 
  거래/리포트가 확장될 때(예: 잔액) 가장 먼저 모델이 커질 영역이므로, 초기에 “원천 추적용 자산”의 의미 경계를 명확히 고정하는 것이 중요합니다.
* 책임: 
  * 자산 등록/수정/비활성(삭제 금지), 유형 관리
  * 거래 입력에서 선택 가능한 자산 목록 제공
  * 자산은 “원천 식별”까지만(Release 1의 의미를 고정)

E. Budget BC (Release 1: Monthly Only)
* 분리 이유:
  예산은 “통제”가 아니라 “비교 기준”으로 제공한다는 제품 포지셔닝이 강합니다. Release 1에서 월 예산만 다룬다는 의사결정은 예산 모델을 단순화하지만, 
  동시에 리포트와 결합되기 쉽습니다. 분리하지 않으면 리포트 표현 변경이 예산 모델을 흔들거나(혹은 반대로) 예산 확장 요구가 리포트를 망가뜨립니다.
* 책임: 
  * 월 예산 설정/변경/조회(YYYY-MM 단위)
  * 예산은 “비교 기준 데이터”로서 제공(계산/표현은 Reporting이 소비)

F. Automation BC (Fixed Cost)
* 분리 이유: 
  고정비 템플릿 및 자동 생성은 운영(스케줄러)과 강하게 결합되어 있고, 실패/재시도/중복 방지 같은 운영 리스크가 큽니다. 
  이 로직이 Ledger 내부로 들어가면 거래 모델이 운영 관심사에 오염됩니다. 반대로 Reporting에 섞이면 집계 모델이 운영 로직을 끌어안게 됩니다. 
  따라서 “규칙(템플릿)과 생성 트리거”를 소유하는 경계가 별도로 필요합니다.
* 책임: 
  * 고정비 템플릿(발생일 day, 예상금액, 기본 분류/자산 등) 관리
  * 월별 자동 생성 트리거(스케줄러 실행) 및 생성 “요청”의 책임
  * 생성된 거래에 “템플릿 기원”이 남도록 Ledger에 전달(사용자가 자동 생성임을 인지 가능)

G. Reporting BC (Core)
* 분리 이유:
  이 제품의 차별점은 “다축 회고(자산/카테고리 롤업/태그) + 월 예산 대비”라는 해석 경험입니다. 즉 Reporting은 Core Domain입니다. 
  Core는 다른 Supporting 모델을 “소비”해 사용자에게 의미 있는 해석을 제공하므로, 쓰기 모델(Ledger 등)과 분리되어야 합니다. 
  Bounded Context를 통해 “집계를 위해 쓰기 모델을 왜곡하지 않는 것”이 핵심입니다.
* 책임: 
  * 월간 리포트 구성(수입/지출/순지출, 자산별 합계, 태그별 합계)
  * 카테고리 축의 기본 표현: 2-depth 기준으로 집계한 후 1-depth로 roll-up하여 대분류 구조로 제공(표현/드릴다운 등은 UX 단계)
  * 예산 대비(월 예산 vs 월 지출) 표시
  * 조회 모델의 형태 결정(초기엔 단순 동기 조합 가능, 후에 이벤트 기반으로 확장 가능)

2.2 컨텍스트 맵(관계)
* Reporting (Downstream) ← Ledger (Upstream): 거래 데이터를 소비해 월 요약/순지출 등을 구성
* Reporting (Downstream) ← Classification (Upstream): 카테고리 구조 및 태그를 참조해 집계/표시
* Reporting (Downstream) ← Asset (Upstream): 자산별 합계 표시
* Reporting (Downstream) ← Budget (Upstream): 예산 대비 계산에 사용
* Ledger (Downstream) ← Automation (Upstream): Automation이 생성 요청을 하고 Ledger가 거래를 소유/저장


통합 방식(동기/비동기, 이벤트, ACL 등)은 전술 설계에서 구체화하되, 
서로 다른 모델을 보호해야 하는 경계에서는 ACL(anti-corruption layer) 같은 보호 계층을 고려할 수 있습니다.

────────────────────────────────────────────────────────
3. 유비쿼터스 언어(초안) 수립
────────────────────────────────────────────────────────
유비쿼터스 언어는 “도메인 전문가와 개발자가 동일 의미로 사용하는 언어”이며, 컨텍스트 내부에서 일관되게 유지되어야 합니다.
동일 단어라도 컨텍스트가 다르면 의미가 달라질 수 있으며(예: ‘사용자’), 이를 방치하면 커뮤니케이션/모델링 비용이 증가합니다.
아래는 컨텍스트별 “핵심 용어 + 의도(한 문장 정의) + 권장 변수명” 수준의 초안입니다. (정밀 정의/불변조건은 SRS(POL)로 이동)

3.1 Identity & Session Context
* 사용자(User): 인증의 주체가 되는 계정(업무 도메인의 ‘사용자 경험’과 구분) (user)
* 주체(Subject): 토큰이 나타내는 당사자. 일반적으로 userId가 매핑됨 (subject, sub)
* 사용자 식별자(User ID): 주체를 식별하는 불변 키 (userId)
* 인증(Authentication): 자격 증명을 검증해 주체를 확인하는 행위 (authentication)
* 세션(Session): 인증 상태를 유지/갱신하기 위한 논리적 단위 (session)
* 액세스 토큰(Access Token): 리소스 요청에 사용되는 단기 토큰 (accessToken)
* 리프레시 토큰(Refresh Token): 액세스 토큰 재발급에 사용되는 장기 토큰 (refreshToken)
* 클레임(Claim): 주체에 대한 정보의 name/value (claim) 
* 발급자(Issuer): 토큰을 발급한 주체 (issuer, iss)
* 만료(Expiration): 토큰 유효기간 (exp)

3.2 Ledger Context
* 거래(Transaction): 수입/지출/이체를 표현하는 원장 이벤트 (transaction)
* 거래 출처(Transaction Source): 거래가 수동 입력인지, 템플릿 자동 생성인지 식별하는 정보 (transactionSource)
* 소유자(Owner): 해당 거래의 주체. 개인 서비스에서는 보통 userId와 동일 (ownerUserId)
* 요청 주체(Principal): 인증을 통과한 호출자(Identity 컨텍스트가 제공하는 userId로 표현) (principalUserId)
* 소유권 검증(Ownership Check): principalUserId와 ownerUserId 일치 여부 확인 (ownershipCheck)

3.3 Classification Context
* 카테고리(Category): 최대 2-depth의 계층형 분류 (category)
* 상위/하위 카테고리(Parent/Child Category): depth=1 / depth=2 (parentCategory, childCategory)
* 태그(Tag): 횡단 분류 키워드 (tag)
* 정규화명(Normalized Name): 태그 중복 방지를 위한 키 (normalizedName)
* 소유자(Owner): 개인별 분류 사전인 경우 userId에 귀속(멀티유저 대비) (ownerUserId)
* 비활성(Deactivated): 삭제 대신 사용 중지(연결은 유지될 수 있음) (isActive)

3.4 Asset Context
* 자산(Asset): 거래 원천(카드/현금/계좌)을 식별하는 단위 (asset)
* 자산유형(Asset Type): CARD/CASH/BANK_ACCOUNT (assetType)
* 소유자(Owner): 자산의 소유 주체(개인 서비스에서는 userId) (ownerUserId)
* 비활성(Deactivated): 신규 선택 불가 상태 (isActive)

3.5 Budget Context
* 월 예산(Monthly Budget): 특정 월의 계획 총액 (monthlyBudget)
* 예산월(Budget Month): YYYY-MM (month)
* 월예산액(Monthly Budget Amount): 계획 금액 (monthlyBudgetAmount)
* 소유자(Owner): 예산 설정의 주체(개인별) (ownerUserId)

3.6 Recurring Context
* 고정비 템플릿(Fixed Cost Template): 매월 반복 생성 규칙의 원천 (fixedCostTemplate)
* 발생일(Day of Month): 매월 생성 기준 일 (dayOfMonth)
* 예상금액(Expected Amount): 기본 생성 금액 (expectedAmount)
* 자동 생성(Auto-generation): 템플릿에 의해 거래 생성이 트리거되는 행위 (autoGeneration)
* 생성 거래 표식(Generated Marker): 생성된 거래가 “템플릿 기원”임을 알리는 연결 정보 (fixedCostTemplateId / transactionSource)
* 소유자(Owner): 템플릿 소유 주체 (ownerUserId)

3.7 Reporting Context
* 월간 리포트(Monthly Report): 특정 월의 해석 결과 뷰 (monthlyReport)
* 카테고리 롤업(Category Roll-up): 2-depth 집계를 1-depth로 통합 표시 (categoryRollup)
* 예산 대비(Budget Compare): 월 지출과 월 예산을 비교해 표시 (budgetCompare)
* 조회 주체(Viewer): 리포트를 조회하는 사용자(원칙적으로 ownerUserId와 동일) (viewerUserId)
* 데이터 소비(Consumption): Upstream 컨텍스트의 데이터를 읽어 조합해 뷰를 구성 (consume)